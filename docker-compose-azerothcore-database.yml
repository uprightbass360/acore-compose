# ==============================================
# AZEROTHCORE DATABASE LAYER - PORTAINER VERSION (CLEAN)
# ==============================================
# Modified for better Portainer compatibility
# Removed redundant ac-mysql-persist service

services:
  # Step 1: MySQL database
  ac-mysql:
    image: ${MYSQL_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_MYSQL}
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_ROOT_HOST: '${MYSQL_ROOT_HOST}'
      MYSQL_ALLOW_EMPTY_PASSWORD: no
      MYSQL_DATADIR: /var/lib/mysql-runtime
    ports:
      - "${MYSQL_EXTERNAL_PORT}:${MYSQL_PORT}"
    volumes:
      - ${STORAGE_PATH}/mysql-data:/var/lib/mysql-persistent
      - ${HOST_BACKUP_PATH}:/backups
      - type: tmpfs
        target: /var/lib/mysql-runtime
        tmpfs:
          size: 2G
    entrypoint: ["/bin/bash", "-c"]
    command:
      - |
        echo "üîß Starting MySQL with NFS-compatible setup and auto-restore..."
        mkdir -p /var/lib/mysql-runtime
        chown -R mysql:mysql /var/lib/mysql-runtime
        chmod 755 /var/lib/mysql-runtime

        # Check if MySQL data directory is empty (fresh start)
        if [ ! -d "/var/lib/mysql-runtime/mysql" ]; then
          echo "üÜï Fresh MySQL installation detected..."

          # Check for available backups (prefer daily, fallback to hourly, then legacy)
          if [ -d "/backups" ] && [ "$(ls -A /backups)" ]; then
            # Try daily backups first
            if [ -d "/backups/daily" ] && [ "$(ls -A /backups/daily)" ]; then
              LATEST_BACKUP=$(ls -1t /backups/daily | head -n 1)
              if [ -n "$LATEST_BACKUP" ] && [ -d "/backups/daily/$LATEST_BACKUP" ]; then
                echo "üì¶ Latest daily backup found: $LATEST_BACKUP"
                echo "üîÑ Will restore after MySQL initializes..."
                export RESTORE_BACKUP="/backups/daily/$LATEST_BACKUP"
              fi
            # Try hourly backups second
            elif [ -d "/backups/hourly" ] && [ "$(ls -A /backups/hourly)" ]; then
              LATEST_BACKUP=$(ls -1t /backups/hourly | head -n 1)
              if [ -n "$LATEST_BACKUP" ] && [ -d "/backups/hourly/$LATEST_BACKUP" ]; then
                echo "üì¶ Latest hourly backup found: $LATEST_BACKUP"
                echo "üîÑ Will restore after MySQL initializes..."
                export RESTORE_BACKUP="/backups/hourly/$LATEST_BACKUP"
              fi
            # Try legacy backup structure last
            else
              LATEST_BACKUP=$(ls -1t /backups | head -n 1)
              if [ -n "$LATEST_BACKUP" ] && [ -d "/backups/$LATEST_BACKUP" ]; then
                echo "üì¶ Latest legacy backup found: $LATEST_BACKUP"
                echo "üîÑ Will restore after MySQL initializes..."
                export RESTORE_BACKUP="/backups/$LATEST_BACKUP"
              else
                echo "üÜï No valid backups found, will initialize fresh..."
              fi
            fi
          else
            echo "üÜï No backup directory found, will initialize fresh..."
          fi
        else
          echo "üìÅ Existing MySQL data found, skipping restore..."
        fi

        echo "üöÄ Starting MySQL server with custom datadir..."

        # Start MySQL in background for potential restore
        if [ -n "$RESTORE_BACKUP" ]; then
          echo "‚ö° Starting MySQL in background for restore operation..."
          docker-entrypoint.sh mysqld \
            --datadir=/var/lib/mysql-runtime \
            --default-authentication-plugin=mysql_native_password \
            --character-set-server=${MYSQL_CHARACTER_SET} \
            --collation-server=${MYSQL_COLLATION} \
            --max_connections=${MYSQL_MAX_CONNECTIONS} \
            --innodb-buffer-pool-size=${MYSQL_INNODB_BUFFER_POOL_SIZE} \
            --innodb-log-file-size=${MYSQL_INNODB_LOG_FILE_SIZE} &

          MYSQL_PID=$!

          # Wait for MySQL to be ready
          echo "‚è≥ Waiting for MySQL to become ready for restore..."
          while ! mysqladmin ping -h localhost -u root --silent; do
            sleep 2
          done

          echo "üîÑ MySQL ready, starting restore from $RESTORE_BACKUP..."

          # Install curl for downloading restore script
          apt-get update && apt-get install -y curl

          # Download restore script from GitHub
          curl -fsSL https://raw.githubusercontent.com/uprightbass360/acore-compose/main/scripts/restore.sh -o /tmp/restore.sh
          chmod +x /tmp/restore.sh

          # Modify restore script to skip confirmation and use correct backup path
          sed -i 's/sleep 10/echo "Auto-restore mode, skipping confirmation..."/' /tmp/restore.sh
          sed -i 's/BACKUP_DIR=\${BACKUP_DIR:-\/backups}/BACKUP_DIR=\/backups/' /tmp/restore.sh
          sed -i 's/MYSQL_PASSWORD=\${MYSQL_PASSWORD:-password}/MYSQL_PASSWORD=${MYSQL_ROOT_PASSWORD}/' /tmp/restore.sh

          # Extract timestamp from backup path and run restore
          BACKUP_TIMESTAMP=$(basename "$RESTORE_BACKUP")
          echo "üóÑÔ∏è  Restoring databases from backup: $BACKUP_TIMESTAMP"
          /tmp/restore.sh "$BACKUP_TIMESTAMP"

          echo "‚úÖ Database restore completed successfully!"

          # Keep MySQL running in foreground
          wait $MYSQL_PID
        else
          # Normal startup without restore
          exec docker-entrypoint.sh mysqld \
            --datadir=/var/lib/mysql-runtime \
            --default-authentication-plugin=mysql_native_password \
            --character-set-server=${MYSQL_CHARACTER_SET} \
            --collation-server=${MYSQL_COLLATION} \
            --max_connections=${MYSQL_MAX_CONNECTIONS} \
            --innodb-buffer-pool-size=${MYSQL_INNODB_BUFFER_POOL_SIZE} \
            --innodb-log-file-size=${MYSQL_INNODB_LOG_FILE_SIZE}
        fi
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "sh", "-c", "mysqladmin ping -h localhost -u ${MYSQL_USER} -p${MYSQL_ROOT_PASSWORD} --silent || exit 1"]
      interval: ${MYSQL_HEALTHCHECK_INTERVAL}
      timeout: ${MYSQL_HEALTHCHECK_TIMEOUT}
      retries: ${MYSQL_HEALTHCHECK_RETRIES}
      start_period: ${MYSQL_HEALTHCHECK_START_PERIOD}
    networks:
      - azerothcore

  # Step 2: Backup service
  ac-backup:
    image: ${MYSQL_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_BACKUP}
    environment:
      MYSQL_HOST: ${CONTAINER_MYSQL}
      MYSQL_PORT: ${MYSQL_PORT}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      BACKUP_RETENTION_DAYS: ${BACKUP_RETENTION_DAYS}
      BACKUP_RETENTION_HOURS: ${BACKUP_RETENTION_HOURS}
      BACKUP_CRON_SCHEDULE: ${BACKUP_CRON_SCHEDULE}
      BACKUP_DIR: ${BACKUP_DIR}
      DB_AUTH_NAME: ${DB_AUTH_NAME}
      DB_WORLD_NAME: ${DB_WORLD_NAME}
      DB_CHARACTERS_NAME: ${DB_CHARACTERS_NAME}
      TZ: ${TZ}
    volumes:
      - ${HOST_BACKUP_PATH}:/backups
    working_dir: /tmp
    command:
      - /bin/bash
      - -c
      - |
        echo "üîß Starting enhanced backup service with hourly and daily schedules..."

        # Install curl if not available
        apt-get update && apt-get install -y curl

        # Download backup scripts from GitHub
        echo "üì• Downloading backup scripts from GitHub..."
        curl -fsSL https://raw.githubusercontent.com/uprightbass360/acore-compose/main/scripts/backup.sh -o /tmp/backup.sh
        curl -fsSL https://raw.githubusercontent.com/uprightbass360/acore-compose/main/scripts/backup-hourly.sh -o /tmp/backup-hourly.sh
        curl -fsSL https://raw.githubusercontent.com/uprightbass360/acore-compose/main/scripts/backup-daily.sh -o /tmp/backup-daily.sh
        chmod +x /tmp/backup.sh /tmp/backup-hourly.sh /tmp/backup-daily.sh

        # Wait for MySQL to be ready before starting backup service
        echo "‚è≥ Waiting for MySQL to be ready..."
        sleep 30

        # Run initial daily backup
        echo "üöÄ Running initial daily backup..."
        /tmp/backup-daily.sh

        # Enhanced scheduler with hourly and daily backups
        echo "‚è∞ Starting enhanced backup scheduler:"
        echo "   üìÖ Daily backups: ${BACKUP_CRON_SCHEDULE} (retention: ${BACKUP_RETENTION_DAYS} days)"
        echo "   ‚è∞ Hourly backups: every hour (retention: ${BACKUP_RETENTION_HOURS} hours)"

        # Track last backup times to avoid duplicates
        last_daily_hour=""
        last_hourly_minute=""

        while true; do
          current_hour=$(date +%H)
          current_minute=$(date +%M)
          current_time="$current_hour:$current_minute"

          # Daily backup check (9:00 AM)
          if [ "$$current_hour" = "09" ] && [ "$$current_minute" = "00" ] && [ "$$last_daily_hour" != "$$current_hour" ]; then
            echo "üìÖ [$(date)] Daily backup time reached, running daily backup..."
            /tmp/backup-daily.sh
            last_daily_hour="$$current_hour"
            # Sleep for 2 minutes to avoid running multiple times
            sleep 120
          # Hourly backup check (every hour at minute 0, except during daily backup)
          elif [ "$$current_minute" = "00" ] && [ "$$current_hour" != "09" ] && [ "$$last_hourly_minute" != "$$current_minute" ]; then
            echo "‚è∞ [$(date)] Hourly backup time reached, running hourly backup..."
            /tmp/backup-hourly.sh
            last_hourly_minute="$$current_minute"
            # Sleep for 2 minutes to avoid running multiple times
            sleep 120
          else
            # Sleep for 1 minute before checking again
            sleep 60
          fi
        done
    restart: unless-stopped
    networks:
      - azerothcore

  # Step 3: Database initialization (one-time setup)
  ac-db-init:
    image: ${MYSQL_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_DB_INIT}
    volumes:
      - ${STORAGE_PATH}/mysql-data:/var/lib/mysql-persistent
    networks:
      - azerothcore
    environment:
      MYSQL_PWD: ${MYSQL_ROOT_PASSWORD}
    command:
      - sh
      - -c
      - |
        echo "üîß Waiting for MySQL to be ready..."

        # Wait for MySQL to be responsive with longer timeout
        for i in $(seq 1 ${DB_WAIT_RETRIES}); do
          if mysql -h ${MYSQL_HOST} -u${MYSQL_USER} -p${MYSQL_ROOT_PASSWORD} -e "SELECT 1;" >/dev/null 2>&1; then
            echo "‚úÖ MySQL is responsive"
            break
          fi
          echo "‚è≥ Waiting for MySQL... attempt $$i/${DB_WAIT_RETRIES}"
          sleep ${DB_WAIT_SLEEP}
        done

        # Check if we should restore from backup
        if [ -f "/var/lib/mysql-persistent/backup.sql" ]; then
          echo "üîÑ Restoring databases from backup..."
          mysql -h ${MYSQL_HOST} -u${MYSQL_USER} -p${MYSQL_ROOT_PASSWORD} < /var/lib/mysql-persistent/backup.sql || {
            echo "‚ö†Ô∏è Backup restore failed, will create fresh databases"
          }
        fi

        echo "üóÑÔ∏è Creating/verifying AzerothCore databases..."
        mysql -h ${MYSQL_HOST} -u${MYSQL_USER} -p${MYSQL_ROOT_PASSWORD} -e "
        CREATE DATABASE IF NOT EXISTS ${DB_AUTH_NAME} DEFAULT CHARACTER SET ${MYSQL_CHARACTER_SET} COLLATE ${MYSQL_COLLATION};
        CREATE DATABASE IF NOT EXISTS ${DB_WORLD_NAME} DEFAULT CHARACTER SET ${MYSQL_CHARACTER_SET} COLLATE ${MYSQL_COLLATION};
        CREATE DATABASE IF NOT EXISTS ${DB_CHARACTERS_NAME} DEFAULT CHARACTER SET ${MYSQL_CHARACTER_SET} COLLATE ${MYSQL_COLLATION};
        SHOW DATABASES;
        " || {
          echo "‚ùå Failed to create databases"
          exit 1
        }
        echo "‚úÖ Databases ready!"
    restart: "no"

  # Step 4: Database import (one-time setup - run after db-init)
  ac-db-import:
    image: ${AC_DB_IMPORT_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_DB_IMPORT}
    user: "0:0"
    networks:
      - azerothcore
    volumes:
      - ${STORAGE_PATH}/config:/azerothcore/env/dist/etc
    environment:
      AC_DATA_DIR: "/azerothcore/data"
      AC_LOGS_DIR: "/azerothcore/logs"
      AC_LOGIN_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_AUTH_NAME}"
      AC_WORLD_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_WORLD_NAME}"
      AC_CHARACTER_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_CHARACTERS_NAME}"
      AC_CLOSE_IDLE_CONNECTIONS: "false"
      AC_UPDATES_ENABLE_DATABASES: "7"
      AC_UPDATES_AUTO_SETUP: "1"
      AC_LOG_LEVEL: "1"
      AC_LOGGER_ROOT_CONFIG: "1,Console"
      AC_LOGGER_SERVER_CONFIG: "1,Console"
      AC_APPENDER_CONSOLE_CONFIG: "1,2,0"
    entrypoint: ["/bin/bash", "-c"]
    command:
      - |
        echo 'Waiting for databases to be ready...'

        # Wait for databases to exist with longer timeout
        for i in $(seq 1 120); do
          if mysql -h ${CONTAINER_MYSQL} -u${MYSQL_USER} -p${MYSQL_ROOT_PASSWORD} -e "USE ${DB_AUTH_NAME}; USE ${DB_WORLD_NAME}; USE ${DB_CHARACTERS_NAME};" >/dev/null 2>&1; then
            echo "‚úÖ All databases accessible"
            break
          fi
          echo "‚è≥ Waiting for databases... attempt $$i/120"
          sleep 5
        done

        echo 'Creating config file for dbimport...'
        mkdir -p /azerothcore/env/dist/etc
        cat > /azerothcore/env/dist/etc/dbimport.conf <<EOF
        LoginDatabaseInfo = "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_AUTH_NAME}"
        WorldDatabaseInfo = "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_WORLD_NAME}"
        CharacterDatabaseInfo = "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_CHARACTERS_NAME}"
        Updates.EnableDatabases = 7
        Updates.AutoSetup = 1
        EOF

        echo 'Running database import...'
        cd /azerothcore/env/dist/bin
        ./dbimport

        echo 'Database import complete!'
    restart: "no"

networks:
  azerothcore:
    driver: bridge
    name: ${NETWORK_NAME}
    ipam:
      config:
        - subnet: ${NETWORK_SUBNET}
          gateway: ${NETWORK_GATEWAY}