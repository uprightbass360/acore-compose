# ==============================================
# AZEROTHCORE SERVICES LAYER (COMBINED)
# ==============================================
# Authentication server, world server, client data, modules, and optional services
# Deploy this layer AFTER the database layer is running

services:
  # Client Data Download Service
  ac-client-data:
    image: ${ALPINE_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_CLIENT_DATA}
    user: "0:0"  # Run as root to install packages
    volumes:
      - ${STORAGE_PATH}/data:/azerothcore/data
      - ${STORAGE_PATH}/cache:/cache
    working_dir: /tmp
    command:
      - sh
      - -c
      - |
        apk add --no-cache curl unzip wget ca-certificates p7zip jq

        # Fix ownership of mount points to match NFS
        chown -R 1001:1001 /azerothcore/data /cache

        # Create cache directory if it doesn't exist
        mkdir -p /cache

        echo 'üöÄ Starting AzerothCore game data setup...'

        # Get the latest release info from wowgaming/client-data
        echo 'üì° Fetching latest client data release info...'
        RELEASE_INFO=$$(wget -qO- https://api.github.com/repos/wowgaming/client-data/releases/latest 2>/dev/null)

        if [ -n "$$RELEASE_INFO" ]; then
          LATEST_URL=$$(echo "$$RELEASE_INFO" | grep '"browser_download_url":' | grep '\.zip' | cut -d'"' -f4 | head -1)
          LATEST_TAG=$$(echo "$$RELEASE_INFO" | grep '"tag_name":' | cut -d'"' -f4)
          LATEST_SIZE=$$(echo "$$RELEASE_INFO" | grep '"size":' | head -1 | grep -o '[0-9]*')
        fi

        if [ -z "$$LATEST_URL" ]; then
          echo '‚ùå Could not fetch latest release URL'
          echo 'üì• Using fallback: direct download from v16 release'
          LATEST_URL='https://github.com/wowgaming/client-data/releases/download/v16/data.zip'
          LATEST_TAG='v16'
          LATEST_SIZE='0'
        fi

        echo "üìç Latest release: $$LATEST_TAG"
        echo "üì• Download URL: $$LATEST_URL"

        # Cache file paths
        CACHE_FILE="/cache/client-data-$$LATEST_TAG.zip"
        VERSION_FILE="/cache/client-data-version.txt"

        # Check if we have a cached version
        if [ -f "$$CACHE_FILE" ] && [ -f "$$VERSION_FILE" ]; then
          CACHED_VERSION=$$(cat "$$VERSION_FILE" 2>/dev/null)
          if [ "$$CACHED_VERSION" = "$$LATEST_TAG" ]; then
            echo "‚úÖ Found cached client data version $$LATEST_TAG"
            echo "üìä Cached file size: $$(ls -lh "$$CACHE_FILE" | awk '{print $$5}')"

            # Verify cache file integrity
            if unzip -t "$$CACHE_FILE" > /dev/null 2>&1; then
              echo "‚úÖ Cache file integrity verified"
              echo "‚ö° Using cached download - skipping download phase"
              cp "$$CACHE_FILE" data.zip
            else
              echo "‚ö†Ô∏è Cache file corrupted, will re-download"
              rm -f "$$CACHE_FILE" "$$VERSION_FILE"
            fi
          else
            echo "üì¶ Cache version ($$CACHED_VERSION) differs from latest ($$LATEST_TAG)"
            echo "üóëÔ∏è Removing old cache"
            rm -f /cache/client-data-*.zip "$$VERSION_FILE"
          fi
        fi

        # Download if we don't have a valid cached file
        if [ ! -f "data.zip" ]; then
          echo "üì• Downloading client data (~15GB, may take 10-30 minutes)..."
          echo "üìç Source: $$LATEST_URL"

          # Download with clean progress indication
          echo "üì• Starting download..."
          wget --progress=dot:giga -O "$$CACHE_FILE.tmp" "$$LATEST_URL" 2>&1 | sed 's/^/üìä /' || {
            echo '‚ùå wget failed, trying curl...'
            curl -L --progress-bar -o "$$CACHE_FILE.tmp" "$$LATEST_URL" || {
              echo '‚ùå All download methods failed'
              rm -f "$$CACHE_FILE.tmp"
              exit 1
            }
          }

          # Verify download integrity
          if unzip -t "$$CACHE_FILE.tmp" > /dev/null 2>&1; then
            mv "$$CACHE_FILE.tmp" "$$CACHE_FILE"
            echo "$$LATEST_TAG" > "$$VERSION_FILE"
            echo '‚úÖ Download completed and verified'
            echo "üìä File size: $$(ls -lh "$$CACHE_FILE" | awk '{print $$5}')"
            cp "$$CACHE_FILE" data.zip
          else
            echo '‚ùå Downloaded file is corrupted'
            rm -f "$$CACHE_FILE.tmp"
            exit 1
          fi
        fi

        echo 'üìÇ Extracting client data (this may take 10-15 minutes)...'
        echo '‚è≥ Please wait while extracting...'

        # Clear existing data if extraction failed previously
        rm -rf /azerothcore/data/maps /azerothcore/data/vmaps /azerothcore/data/mmaps /azerothcore/data/dbc

        # Extract with detailed progress tracking
        echo 'üîÑ Starting extraction with progress monitoring...'

        # Start extraction in background with overwrite
        unzip -o -q data.zip -d /azerothcore/data/ &

        UNZIP_PID=$!
        LAST_CHECK_TIME=0

        # Monitor progress with directory size checks
        while kill -0 "$$UNZIP_PID" 2>/dev/null; do
          CURRENT_TIME=$$(date +%s)
          if [ $$((CURRENT_TIME - LAST_CHECK_TIME)) -ge 30 ]; then
            LAST_CHECK_TIME=$$CURRENT_TIME

            # Check what's been extracted so far
            PROGRESS_MSG="üìä Progress at $$(date '+%H:%M:%S'):"

            if [ -d "/azerothcore/data/dbc" ] && [ -n "$$(ls -A /azerothcore/data/dbc 2>/dev/null)" ]; then
              DBC_SIZE=$$(du -sh /azerothcore/data/dbc 2>/dev/null | cut -f1)
              PROGRESS_MSG="$$PROGRESS_MSG DBC($$DBC_SIZE)"
            fi

            if [ -d "/azerothcore/data/maps" ] && [ -n "$$(ls -A /azerothcore/data/maps 2>/dev/null)" ]; then
              MAPS_SIZE=$$(du -sh /azerothcore/data/maps 2>/dev/null | cut -f1)
              PROGRESS_MSG="$$PROGRESS_MSG Maps($$MAPS_SIZE)"
            fi

            if [ -d "/azerothcore/data/vmaps" ] && [ -n "$$(ls -A /azerothcore/data/vmaps 2>/dev/null)" ]; then
              VMAPS_SIZE=$$(du -sh /azerothcore/data/vmaps 2>/dev/null | cut -f1)
              PROGRESS_MSG="$$PROGRESS_MSG VMaps($$VMAPS_SIZE)"
            fi

            if [ -d "/azerothcore/data/mmaps" ] && [ -n "$$(ls -A /azerothcore/data/mmaps 2>/dev/null)" ]; then
              MMAPS_SIZE=$$(du -sh /azerothcore/data/mmaps 2>/dev/null | cut -f1)
              PROGRESS_MSG="$$PROGRESS_MSG MMaps($$MMAPS_SIZE)"
            fi

            echo "$$PROGRESS_MSG"
          fi
          sleep 5
        done

        wait "$$UNZIP_PID"
        UNZIP_EXIT_CODE=$?

        if [ $$UNZIP_EXIT_CODE -ne 0 ]; then
          echo '‚ùå Extraction failed'
          rm -f data.zip
          exit 1
        fi

        # Clean up temporary extraction file (keep cached version)
        rm -f data.zip

        echo '‚úÖ Client data extraction complete!'
        echo 'üìÅ Verifying extracted directories:'

        # Verify required directories exist and have content
        ALL_GOOD=true
        for dir in maps vmaps mmaps dbc; do
          if [ -d "/azerothcore/data/$$dir" ] && [ -n "$$(ls -A /azerothcore/data/$$dir 2>/dev/null)" ]; then
            DIR_SIZE=$$(du -sh /azerothcore/data/$$dir 2>/dev/null | cut -f1)
            echo "‚úÖ $$dir directory: OK ($$DIR_SIZE)"
          else
            echo "‚ùå $$dir directory: MISSING or EMPTY"
            ALL_GOOD=false
          fi
        done

        if [ "$$ALL_GOOD" = "true" ]; then
          echo 'üéâ Game data setup complete! AzerothCore worldserver can now start.'
          echo "üíæ Cached version $$LATEST_TAG for future use"
        else
          echo '‚ùå Some directories are missing or empty'
          exit 1
        fi
    restart: "no"
    networks:
      - azerothcore

  # Auth server
  ac-authserver:
    image: ${AC_AUTHSERVER_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_AUTHSERVER}
    user: "0:0"  # Run as root to handle NFS permissions
    environment:
      AC_LOGIN_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_AUTH_NAME}"
      AC_UPDATES_ENABLE_DATABASES: "0"
      AC_BIND_IP: "0.0.0.0"
      AC_LOG_LEVEL: "1"
      AC_LOGGER_ROOT_CONFIG: "1,Console"
      AC_LOGGER_SERVER_CONFIG: "1,Console"
      AC_APPENDER_CONSOLE_CONFIG: "1,2,0"
    ports:
      - "${DOCKER_AUTH_EXTERNAL_PORT}:${AUTH_PORT}"
    restart: unless-stopped
    networks:
      - azerothcore
    volumes:
      - ${STORAGE_PATH}/config:/azerothcore/env/dist/etc
    cap_add:
      - SYS_NICE
    healthcheck:
      test: ["CMD", "sh", "-c", "ps aux | grep '[a]uthserver' | grep -v grep || exit 1"]
      interval: ${AUTH_HEALTHCHECK_INTERVAL}
      timeout: ${AUTH_HEALTHCHECK_TIMEOUT}
      retries: ${AUTH_HEALTHCHECK_RETRIES}
      start_period: ${AUTH_HEALTHCHECK_START_PERIOD}

  # World server with Playerbots support
  ac-worldserver:
    image: ${AC_WORLDSERVER_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_WORLDSERVER}
    user: "0:0"  # Run as root to handle NFS permissions
    stdin_open: true
    tty: true
    depends_on:
      - ac-authserver
      - ac-client-data
    environment:
      AC_LOGIN_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_AUTH_NAME}"
      AC_WORLD_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_WORLD_NAME}"
      AC_CHARACTER_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_CHARACTERS_NAME}"
      AC_UPDATES_ENABLE_DATABASES: "0"
      AC_BIND_IP: "0.0.0.0"
      AC_DATA_DIR: "/azerothcore/data"
      AC_SOAP_PORT: "7878"
      AC_PROCESS_PRIORITY: "0"
      PLAYERBOT_ENABLED: "${PLAYERBOT_ENABLED}"
      PLAYERBOT_MAX_BOTS: "${PLAYERBOT_MAX_BOTS}"
      # Logger configuration - Use config file defaults with proper log level
      AC_LOG_LEVEL: "2"
    ports:
      - "${DOCKER_WORLD_EXTERNAL_PORT}:${WORLD_PORT}"
      - "${DOCKER_SOAP_EXTERNAL_PORT}:${SOAP_PORT}"
    volumes:
      - ${STORAGE_PATH}/data:/azerothcore/data
      - ${STORAGE_PATH}/config:/azerothcore/env/dist/etc
      - ${STORAGE_PATH}/logs:/azerothcore/logs
      - ${STORAGE_PATH}/modules:/azerothcore/modules
    restart: unless-stopped
    networks:
      - azerothcore
    cap_add:
      - SYS_NICE
    healthcheck:
      test: ["CMD", "sh", "-c", "ps aux | grep '[w]orldserver' | grep -v grep || exit 1"]
      interval: ${WORLD_HEALTHCHECK_INTERVAL}
      timeout: ${WORLD_HEALTHCHECK_TIMEOUT}
      retries: ${WORLD_HEALTHCHECK_RETRIES}
      start_period: ${WORLD_HEALTHCHECK_START_PERIOD}

  # Optional: Eluna Lua Engine
  ac-eluna:
    image: ${AC_ELUNA_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_ELUNA}
    user: "0:0"  # Run as root to handle NFS permissions
    restart: unless-stopped
    networks:
      - azerothcore

  # Module Management Service
  ac-modules:
    image: ${ALPINE_GIT_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_MODULES}
    user: "0:0"  # Run as root to handle NFS permissions
    volumes:
      - ${STORAGE_PATH}/modules:/modules
    environment:
      - MODULE_PLAYERBOTS=${MODULE_PLAYERBOTS}
      - MODULE_AOE_LOOT=${MODULE_AOE_LOOT}
      - MODULE_LEARN_SPELLS=${MODULE_LEARN_SPELLS}
      - MODULE_FIREWORKS=${MODULE_FIREWORKS}
      - MODULE_INDIVIDUAL_PROGRESSION=${MODULE_INDIVIDUAL_PROGRESSION}
      - DEPLOYMENT_MODE=${DEPLOYMENT_MODE}
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        echo 'Initializing module management...'
        cd /modules

        if [ "$DEPLOYMENT_MODE" = "portainer" ]; then
          echo 'Simple module setup for Portainer deployment...'
          mkdir -p mod-playerbots
          echo '‚úÖ Playerbot module directory created'
        else
          echo 'Advanced module setup for local development...'
          # Install Playerbots if enabled
          if [ "$MODULE_PLAYERBOTS" = "1" ] && [ ! -d "mod-playerbots" ]; then
            echo 'Installing mod-playerbots...'
            git clone https://github.com/liyunfan1223/mod-playerbots.git mod-playerbots
          fi

          # Install AOE Loot if enabled
          if [ "$MODULE_AOE_LOOT" = "1" ] && [ ! -d "mod-aoe-loot" ]; then
            echo 'Installing mod-aoe-loot...'
            git clone https://github.com/azerothcore/mod-aoe-loot.git mod-aoe-loot
          fi

          # Install Learn Spells if enabled
          if [ "$MODULE_LEARN_SPELLS" = "1" ] && [ ! -d "mod-learn-spells" ]; then
            echo 'Installing mod-learn-spells...'
            git clone https://github.com/azerothcore/mod-learn-spells.git mod-learn-spells
          fi

          # Install Fireworks on Level if enabled
          if [ "$MODULE_FIREWORKS" = "1" ] && [ ! -d "mod-fireworks-on-level" ]; then
            echo 'Installing mod-fireworks-on-level...'
            git clone https://github.com/azerothcore/mod-fireworks-on-level.git mod-fireworks-on-level
          fi

          # Install Individual Progression if enabled
          if [ "$MODULE_INDIVIDUAL_PROGRESSION" = "1" ] && [ ! -d "mod-individual-progression" ]; then
            echo 'Installing mod-individual-progression...'
            git clone https://github.com/azerothcore/mod-individual-progression.git mod-individual-progression
          fi
        fi

        echo 'Module management complete. Keeping container alive...'
        tail -f /dev/null
    restart: "no"
    networks:
      - azerothcore

networks:
  azerothcore:
    external: true
    name: ${NETWORK_NAME}