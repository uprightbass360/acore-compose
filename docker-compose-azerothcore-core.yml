# ==============================================
# AZEROTHCORE UNIFIED DOCKER COMPOSE
# ==============================================
# Compatible with both local development and Portainer deployment
# Set DEPLOYMENT_MODE=local|portainer in .env file

services:
  # Step 0: Fix MySQL volume permissions
  ac-mysql-init:
    image: ${ALPINE_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_MYSQL_INIT}
    user: "0:0"
    volumes:
      - ${STORAGE_PATH}/mysql:/mysql-data
    command:
      - sh
      - -c
      - |
        echo "ðŸ”§ Initializing MySQL data directory permissions..."

        # Create the directory structure
        mkdir -p /mysql-data

        # Set broad permissions to ensure MySQL can access
        chmod 777 /mysql-data

        # Create a marker file to indicate initialization is complete
        touch /mysql-data/.permissions-fixed

        echo "âœ… MySQL data directory permissions initialized"
    restart: "no"
    networks:
      - azerothcore

  # Step 1: Standard MySQL database
  ac-mysql:
    image: ${MYSQL_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_MYSQL}
    user: "0:0"  # Run as root to handle NFS permissions
    depends_on:
      - ac-mysql-init
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_ROOT_HOST: '${MYSQL_ROOT_HOST}'
      MYSQL_ALLOW_EMPTY_PASSWORD: no
    ports:
      - "${DOCKER_DB_EXTERNAL_PORT}:${MYSQL_PORT}"
    volumes:
      - ${STORAGE_PATH}/mysql:/var/lib/mysql
    command:
      - mysqld
      - --default-authentication-plugin=mysql_native_password
      - --character-set-server=${MYSQL_CHARACTER_SET}
      - --collation-server=${MYSQL_COLLATION}
      - --max_connections=${MYSQL_MAX_CONNECTIONS}
      - --innodb-buffer-pool-size=${MYSQL_INNODB_BUFFER_POOL_SIZE}
      - --innodb-log-file-size=${MYSQL_INNODB_LOG_FILE_SIZE}
      - --user=root
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "sh", "-c", "mysqladmin ping -h localhost -u ${MYSQL_USER} -p${MYSQL_ROOT_PASSWORD} --silent || exit 1"]
      interval: ${MYSQL_HEALTHCHECK_INTERVAL}
      timeout: ${MYSQL_HEALTHCHECK_TIMEOUT}
      retries: ${MYSQL_HEALTHCHECK_RETRIES}
      start_period: ${MYSQL_HEALTHCHECK_START_PERIOD}
    networks:
      - azerothcore

  # Step 2: Initialize databases
  ac-db-init:
    image: ${MYSQL_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_DB_INIT}
    depends_on:
      ac-mysql:
        condition: service_healthy
    networks:
      - azerothcore
    environment:
      MYSQL_PWD: ${MYSQL_ROOT_PASSWORD}
    command:
      - sh
      - -c
      - |
        echo "ðŸ”§ Waiting for MySQL to be ready..."

        # Wait for MySQL to be responsive
        for i in $(seq 1 ${DB_WAIT_RETRIES}); do
          if mysql -h ${MYSQL_HOST} -u${MYSQL_USER} -p${MYSQL_ROOT_PASSWORD} -e "SELECT 1;" >/dev/null 2>&1; then
            echo "âœ… MySQL is responsive"
            break
          fi
          echo "â³ Waiting for MySQL... attempt $i/${DB_WAIT_RETRIES}"
          sleep ${DB_WAIT_SLEEP}
        done

        echo "ðŸ—„ï¸ Creating AzerothCore databases..."
        mysql -h ${MYSQL_HOST} -u${MYSQL_USER} -p${MYSQL_ROOT_PASSWORD} -e "
        CREATE DATABASE IF NOT EXISTS ${DB_AUTH_NAME} DEFAULT CHARACTER SET ${MYSQL_CHARACTER_SET} COLLATE ${MYSQL_COLLATION};
        CREATE DATABASE IF NOT EXISTS ${DB_WORLD_NAME} DEFAULT CHARACTER SET ${MYSQL_CHARACTER_SET} COLLATE ${MYSQL_COLLATION};
        CREATE DATABASE IF NOT EXISTS ${DB_CHARACTERS_NAME} DEFAULT CHARACTER SET ${MYSQL_CHARACTER_SET} COLLATE ${MYSQL_COLLATION};
        SHOW DATABASES;
        " || {
          echo "âŒ Failed to create databases"
          exit 1
        }
        echo "âœ… Databases created successfully!"
    restart: "no"

  # Step 3: Import AzerothCore database schema and data
  ac-db-import:
    image: ${AC_DB_IMPORT_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_DB_IMPORT}
    user: "0:0"  # Run as root to handle NFS permissions
    depends_on:
      - ac-db-init
    networks:
      - azerothcore
    volumes:
      - ${STORAGE_PATH}/config:/azerothcore/env/dist/etc
    environment:
      AC_DATA_DIR: "/azerothcore/data"
      AC_LOGS_DIR: "/azerothcore/logs"
      AC_LOGIN_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_AUTH_NAME}"
      AC_WORLD_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_WORLD_NAME}"
      AC_CHARACTER_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_CHARACTERS_NAME}"
      AC_CLOSE_IDLE_CONNECTIONS: "false"
      AC_UPDATES_ENABLE_DATABASES: "7"
      AC_UPDATES_AUTO_SETUP: "1"
      AC_LOG_LEVEL: "1"
      AC_LOGGER_ROOT_CONFIG: "1,Console"
      AC_LOGGER_SERVER_CONFIG: "1,Console"
      AC_APPENDER_CONSOLE_CONFIG: "1,2,0"
    entrypoint: ["/bin/bash", "-c"]
    command:
      - |
        echo 'Waiting for databases to be ready...'
        sleep 10

        echo 'Creating config file for dbimport...'
        mkdir -p /azerothcore/env/dist/etc
        cat > /azerothcore/env/dist/etc/dbimport.conf <<EOF
        LoginDatabaseInfo = "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_AUTH_NAME}"
        WorldDatabaseInfo = "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_WORLD_NAME}"
        CharacterDatabaseInfo = "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_CHARACTERS_NAME}"
        Updates.EnableDatabases = 7
        Updates.AutoSetup = 1
        EOF

        echo 'Running database import...'
        cd /azerothcore/env/dist/bin
        ./dbimport

        echo 'Database import complete!'
    restart: "no"

  # Step 4: Auth server
  ac-authserver:
    image: ${AC_AUTHSERVER_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_AUTHSERVER}
    user: "0:0"  # Run as root to handle NFS permissions
    depends_on:
      - ac-db-import
    environment:
      AC_LOGIN_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_AUTH_NAME}"
      AC_UPDATES_ENABLE_DATABASES: "0"
      AC_BIND_IP: "0.0.0.0"
      AC_LOG_LEVEL: "1"
      AC_LOGGER_ROOT_CONFIG: "1,Console"
      AC_LOGGER_SERVER_CONFIG: "1,Console"
      AC_APPENDER_CONSOLE_CONFIG: "1,2,0"
    ports:
      - "${DOCKER_AUTH_EXTERNAL_PORT}:${AUTH_PORT}"
    restart: unless-stopped
    networks:
      - azerothcore
    volumes:
      - ${STORAGE_PATH}/config:/azerothcore/env/dist/etc
    cap_add:
      - SYS_NICE
    healthcheck:
      test: ["CMD", "sh", "-c", "ps aux | grep '[a]uthserver' | grep -v grep || exit 1"]
      interval: ${AUTH_HEALTHCHECK_INTERVAL}
      timeout: ${AUTH_HEALTHCHECK_TIMEOUT}
      retries: ${AUTH_HEALTHCHECK_RETRIES}
      start_period: ${AUTH_HEALTHCHECK_START_PERIOD}

  # Client Data Download Service
  ac-client-data:
    image: ${ALPINE_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_CLIENT_DATA}
    user: "0:0"  # Run as root to handle NFS permissions
    volumes:
      - ${STORAGE_PATH}/data:/azerothcore/data
      - ${STORAGE_PATH}/cache:/cache
    working_dir: /tmp
    command:
      - sh
      - -c
      - |
        apk add --no-cache curl unzip wget ca-certificates p7zip jq

        # Create cache directory if it doesn't exist
        mkdir -p /cache

        # Check if game data already exists
        if [ -d '/azerothcore/data/maps' ] && [ -d '/azerothcore/data/vmaps' ] && [ -d '/azerothcore/data/mmaps' ] && [ -d '/azerothcore/data/dbc' ]; then
          echo 'âœ… Game data already exists, verifying integrity...'

          # Quick verification of required directories
          MISSING_DIRS=""
          for dir in maps vmaps mmaps dbc; do
            if [ ! -d "/azerothcore/data/$$dir" ] || [ -z "$$(ls -A /azerothcore/data/$$dir 2>/dev/null)" ]; then
              MISSING_DIRS="$$MISSING_DIRS $$dir"
            fi
          done

          if [ -z "$$MISSING_DIRS" ]; then
            echo 'âœ… All game data directories verified, startup complete!'
            exit 0
          else
            echo "âš ï¸ Missing or empty directories:$$MISSING_DIRS"
            echo "ðŸ”„ Re-extracting game data..."
          fi
        fi

        echo 'ðŸš€ Starting AzerothCore game data setup...'

        # Get the latest release info from wowgaming/client-data
        echo 'ðŸ“¡ Fetching latest client data release info...'
        RELEASE_INFO=$$(wget -qO- https://api.github.com/repos/wowgaming/client-data/releases/latest 2>/dev/null)

        if [ -n "$$RELEASE_INFO" ]; then
          LATEST_URL=$$(echo "$$RELEASE_INFO" | grep '"browser_download_url":' | grep '\.zip' | cut -d'"' -f4 | head -1)
          LATEST_TAG=$$(echo "$$RELEASE_INFO" | grep '"tag_name":' | cut -d'"' -f4)
          LATEST_SIZE=$$(echo "$$RELEASE_INFO" | grep '"size":' | head -1 | grep -o '[0-9]*')
        fi

        if [ -z "$$LATEST_URL" ]; then
          echo 'âŒ Could not fetch latest release URL'
          echo 'ðŸ“¥ Using fallback: direct download from v16 release'
          LATEST_URL='https://github.com/wowgaming/client-data/releases/download/v16/data.zip'
          LATEST_TAG='v16'
          LATEST_SIZE='0'
        fi

        echo "ðŸ“ Latest release: $$LATEST_TAG"
        echo "ðŸ“¥ Download URL: $$LATEST_URL"

        # Cache file paths
        CACHE_FILE="/cache/client-data-$$LATEST_TAG.zip"
        VERSION_FILE="/cache/client-data-version.txt"

        # Check if we have a cached version
        if [ -f "$$CACHE_FILE" ] && [ -f "$$VERSION_FILE" ]; then
          CACHED_VERSION=$$(cat "$$VERSION_FILE" 2>/dev/null)
          if [ "$$CACHED_VERSION" = "$$LATEST_TAG" ]; then
            echo "âœ… Found cached client data version $$LATEST_TAG"
            echo "ðŸ“Š Cached file size: $$(ls -lh "$$CACHE_FILE" | awk '{print $$5}')"

            # Verify cache file integrity
            if unzip -t "$$CACHE_FILE" > /dev/null 2>&1; then
              echo "âœ… Cache file integrity verified"
              echo "âš¡ Using cached download - skipping download phase"
              cp "$$CACHE_FILE" data.zip
            else
              echo "âš ï¸ Cache file corrupted, will re-download"
              rm -f "$$CACHE_FILE" "$$VERSION_FILE"
            fi
          else
            echo "ðŸ“¦ Cache version ($$CACHED_VERSION) differs from latest ($$LATEST_TAG)"
            echo "ðŸ—‘ï¸ Removing old cache"
            rm -f /cache/client-data-*.zip "$$VERSION_FILE"
          fi
        fi

        # Download if we don't have a valid cached file
        if [ ! -f "data.zip" ]; then
          echo "ðŸ“¥ Downloading client data (~15GB, may take 10-30 minutes)..."
          echo "ðŸ“ Source: $$LATEST_URL"

          # Download with progress indication
          wget --progress=bar:force -O "$$CACHE_FILE.tmp" "$$LATEST_URL" || {
            echo 'âŒ wget failed, trying curl...'
            curl -L --progress-bar -o "$$CACHE_FILE.tmp" "$$LATEST_URL" || {
              echo 'âŒ All download methods failed'
              rm -f "$$CACHE_FILE.tmp"
              exit 1
            }
          }

          # Verify download integrity
          if unzip -t "$$CACHE_FILE.tmp" > /dev/null 2>&1; then
            mv "$$CACHE_FILE.tmp" "$$CACHE_FILE"
            echo "$$LATEST_TAG" > "$$VERSION_FILE"
            echo 'âœ… Download completed and verified'
            echo "ðŸ“Š File size: $$(ls -lh "$$CACHE_FILE" | awk '{print $$5}')"
            cp "$$CACHE_FILE" data.zip
          else
            echo 'âŒ Downloaded file is corrupted'
            rm -f "$$CACHE_FILE.tmp"
            exit 1
          fi
        fi

        echo 'ðŸ“‚ Extracting client data (this may take 10-15 minutes)...'
        echo 'â³ Please wait while extracting...'

        # Clear existing data if extraction failed previously
        rm -rf /azerothcore/data/maps /azerothcore/data/vmaps /azerothcore/data/mmaps /azerothcore/data/dbc

        unzip -q data.zip -d /azerothcore/data/ || {
          echo 'âŒ Extraction failed'
          rm -f data.zip
          exit 1
        }

        # Clean up temporary extraction file (keep cached version)
        rm -f data.zip

        echo 'âœ… Client data extraction complete!'
        echo 'ðŸ“ Verifying extracted directories:'

        # Verify required directories exist and have content
        ALL_GOOD=true
        for dir in maps vmaps mmaps dbc; do
          if [ -d "/azerothcore/data/$$dir" ] && [ -n "$$(ls -A /azerothcore/data/$$dir 2>/dev/null)" ]; then
            DIR_SIZE=$$(du -sh /azerothcore/data/$$dir 2>/dev/null | cut -f1)
            echo "âœ… $$dir directory: OK ($$DIR_SIZE)"
          else
            echo "âŒ $$dir directory: MISSING or EMPTY"
            ALL_GOOD=false
          fi
        done

        if [ "$$ALL_GOOD" = "true" ]; then
          echo 'ðŸŽ‰ Game data setup complete! AzerothCore worldserver can now start.'
          echo "ðŸ’¾ Cached version $$LATEST_TAG for future use"
        else
          echo 'âŒ Some directories are missing or empty'
          exit 1
        fi
    restart: "no"
    networks:
      - azerothcore

  # Step 5: World server with Playerbots support
  ac-worldserver:
    image: ${AC_WORLDSERVER_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_WORLDSERVER}
    user: "0:0"  # Run as root to handle NFS permissions
    stdin_open: true
    tty: true
    depends_on:
      - ac-authserver
      - ac-client-data
    environment:
      AC_LOGIN_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_AUTH_NAME}"
      AC_WORLD_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_WORLD_NAME}"
      AC_CHARACTER_DATABASE_INFO: "${CONTAINER_MYSQL};${MYSQL_PORT};${MYSQL_USER};${MYSQL_ROOT_PASSWORD};${DB_CHARACTERS_NAME}"
      AC_UPDATES_ENABLE_DATABASES: "0"
      AC_BIND_IP: "0.0.0.0"
      AC_DATA_DIR: "/azerothcore/data"
      AC_SOAP_PORT: "7878"
      AC_PROCESS_PRIORITY: "0"
      PLAYERBOT_ENABLED: "${PLAYERBOT_ENABLED}"
      PLAYERBOT_MAX_BOTS: "${PLAYERBOT_MAX_BOTS}"
      # Logger configuration - Use config file defaults with proper log level
      AC_LOG_LEVEL: "2"
    ports:
      - "${DOCKER_WORLD_EXTERNAL_PORT}:${WORLD_PORT}"
      - "${DOCKER_SOAP_EXTERNAL_PORT}:${SOAP_PORT}"
    volumes:
      - ${STORAGE_PATH}/data:/azerothcore/data
      - ${STORAGE_PATH}/config:/azerothcore/env/dist/etc
      - ${STORAGE_PATH}/logs:/azerothcore/logs
      - ${STORAGE_PATH}/modules:/azerothcore/modules
    restart: unless-stopped
    networks:
      - azerothcore
    cap_add:
      - SYS_NICE
    healthcheck:
      test: ["CMD", "sh", "-c", "ps aux | grep '[w]orldserver' | grep -v grep || exit 1"]
      interval: ${WORLD_HEALTHCHECK_INTERVAL}
      timeout: ${WORLD_HEALTHCHECK_TIMEOUT}
      retries: ${WORLD_HEALTHCHECK_RETRIES}
      start_period: ${WORLD_HEALTHCHECK_START_PERIOD}

  # Optional: Eluna Lua Engine
  ac-eluna:
    image: ${AC_ELUNA_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_ELUNA}
    depends_on:
      - ac-worldserver
    restart: unless-stopped
    networks:
      - azerothcore

  # Module Management Service
  ac-modules:
    image: ${ALPINE_GIT_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_MODULES}
    user: "0:0"  # Run as root to handle NFS permissions
    volumes:
      - ${STORAGE_PATH}/modules:/modules
    environment:
      - MODULE_PLAYERBOTS=${MODULE_PLAYERBOTS}
      - MODULE_AOE_LOOT=${MODULE_AOE_LOOT}
      - MODULE_LEARN_SPELLS=${MODULE_LEARN_SPELLS}
      - MODULE_FIREWORKS=${MODULE_FIREWORKS}
      - MODULE_INDIVIDUAL_PROGRESSION=${MODULE_INDIVIDUAL_PROGRESSION}
      - DEPLOYMENT_MODE=${DEPLOYMENT_MODE}
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        echo 'Initializing module management...'
        cd /modules

        if [ "$DEPLOYMENT_MODE" = "portainer" ]; then
          echo 'Simple module setup for Portainer deployment...'
          mkdir -p mod-playerbots
          echo 'âœ… Playerbot module directory created'
        else
          echo 'Advanced module setup for local development...'
          # Install Playerbots if enabled
          if [ "$MODULE_PLAYERBOTS" = "1" ] && [ ! -d "mod-playerbots" ]; then
            echo 'Installing mod-playerbots...'
            git clone https://github.com/liyunfan1223/mod-playerbots.git mod-playerbots
          fi

          # Install AOE Loot if enabled
          if [ "$MODULE_AOE_LOOT" = "1" ] && [ ! -d "mod-aoe-loot" ]; then
            echo 'Installing mod-aoe-loot...'
            git clone https://github.com/azerothcore/mod-aoe-loot.git mod-aoe-loot
          fi

          # Install Learn Spells if enabled
          if [ "$MODULE_LEARN_SPELLS" = "1" ] && [ ! -d "mod-learn-spells" ]; then
            echo 'Installing mod-learn-spells...'
            git clone https://github.com/azerothcore/mod-learn-spells.git mod-learn-spells
          fi

          # Install Fireworks on Level if enabled
          if [ "$MODULE_FIREWORKS" = "1" ] && [ ! -d "mod-fireworks-on-level" ]; then
            echo 'Installing mod-fireworks-on-level...'
            git clone https://github.com/azerothcore/mod-fireworks-on-level.git mod-fireworks-on-level
          fi

          # Install Individual Progression if enabled
          if [ "$MODULE_INDIVIDUAL_PROGRESSION" = "1" ] && [ ! -d "mod-individual-progression" ]; then
            echo 'Installing mod-individual-progression...'
            git clone https://github.com/azerothcore/mod-individual-progression.git mod-individual-progression
          fi
        fi

        echo 'Module management complete. Keeping container alive...'
        tail -f /dev/null
    restart: "no"
    networks:
      - azerothcore


  # Automated Backup System
  ac-backup:
    image: ${MYSQL_IMAGE}
    pull_policy: ${IMAGE_PULL_POLICY}
    container_name: ${CONTAINER_BACKUP}
    depends_on:
      ac-mysql:
        condition: service_healthy
    environment:
      MYSQL_HOST: ${CONTAINER_MYSQL}
      MYSQL_PORT: ${MYSQL_PORT}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      BACKUP_RETENTION_DAYS: ${BACKUP_RETENTION_DAYS}
      BACKUP_CRON_SCHEDULE: ${BACKUP_CRON_SCHEDULE}
      TZ: ${TZ}
    volumes:
      - ${HOST_BACKUP_PATH}:/backups
      - ${HOST_BACKUP_SCRIPTS_PATH}:/scripts
    working_dir: /scripts
    command:
      - /bin/bash
      - -c
      - |
        apt-get update && apt-get install -y cron
        chmod +x /scripts/*.sh 2>/dev/null || echo 'No scripts to make executable'
        touch /var/log/backup.log
        echo "$$BACKUP_CRON_SCHEDULE /scripts/backup.sh >> /var/log/backup.log 2>&1" | crontab -
        echo "Starting backup service with schedule: $$BACKUP_CRON_SCHEDULE"
        echo "Backup retention: $$BACKUP_RETENTION_DAYS days"
        echo "Scripts location: /scripts"
        echo "Backup location: /backups"
        if [ -f "/scripts/backup.sh" ]; then
          echo "Running initial backup..."
          /scripts/backup.sh >> /var/log/backup.log 2>&1
        else
          echo "No backup script found at /scripts/backup.sh"
        fi
        echo "Starting cron daemon..."
        /etc/init.d/cron start
        tail -f /var/log/backup.log
    restart: unless-stopped
    networks:
      - azerothcore


networks:
  azerothcore:
    driver: bridge
    name: ${NETWORK_NAME}
    ipam:
      config:
        - subnet: ${NETWORK_SUBNET}
          gateway: ${NETWORK_GATEWAY}